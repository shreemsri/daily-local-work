<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>White 4D Tesseract</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000000; }
        video { display: none; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #ffffff; /* Changed title color to white */
            font-family: 'Courier New', Courier, monospace;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 10px #ffffff; /* White glow */
            background: rgba(0,0,0,0.5);
            padding: 10px 0;
            letter-spacing: 2px;
        }
        .controls { font-size: 12px; opacity: 0.8; margin-top: 5px; font-weight: bold;}
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-family: monospace;
            font-size: 20px;
            text-transform: uppercase;
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="info">
        <h3>üî≥ White 4D Hypercube</h3>
        <div class="controls">
            üñê <b>Hand X/Y:</b> Manual 4D Rotation | ü§è <b>Pinch:</b> Expand
        </div>
    </div>
    <div id="loading">Initializing Geometry...</div>
    <video id="input_video"></video>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 20000;
    const TESSERACT_SCALE = 15;
    const PROJECTION_DISTANCE = 30; 

    // --- SETUP SCENE ---
    const scene = new THREE.Scene();
    // Use a very subtle white fog instead of black
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 60);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = false;

    // --- TEXTURE (Updated to Pure White) ---
    function createGlintTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        // Core center bright white
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        // Mid-range soft white
        gradient.addColorStop(0.4, 'rgba(255,255,255,0.6)');
        // Outer edge transparent
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        
        ctx.fillStyle = gradient;
        // Draw a soft circle instead of a sharp diamond for a smoother look
        ctx.beginPath();
        ctx.arc(32, 32, 32, 0, Math.PI * 2);
        ctx.fill();
        return new THREE.CanvasTexture(canvas);
    }

    // --- 4D ROTATION MATH ---
    function rotateXW(pos4D, angle) {
        const x = pos4D[0]; const w = pos4D[3];
        const cos = Math.cos(angle); const sin = Math.sin(angle);
        pos4D[0] = x * cos - w * sin;
        pos4D[3] = x * sin + w * cos;
    }
    function rotateYW(pos4D, angle) {
        const y = pos4D[1]; const w = pos4D[3];
        const cos = Math.cos(angle); const sin = Math.sin(angle);
        pos4D[1] = y * cos - w * sin;
        pos4D[3] = y * sin + w * cos;
    }

    function project4Dto3D(x, y, z, w, targetArray, index) {
        const perspective = 1 / (PROJECTION_DISTANCE - w);
        targetArray[index] = x * perspective * TESSERACT_SCALE * 2;
        targetArray[index + 1] = y * perspective * TESSERACT_SCALE * 2;
        targetArray[index + 2] = z * perspective * TESSERACT_SCALE * 2;
    }

    // --- GENERATE GEOMETRY ---
    const geometry = new THREE.BufferGeometry();
    const positions4DStrg = new Float32Array(PARTICLE_COUNT * 4); 
    const positions3D = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i4 = i * 4; const i3 = i * 3;
        let x = (Math.random() - 0.5) * 2;
        let y = (Math.random() - 0.5) * 2;
        let z = (Math.random() - 0.5) * 2;
        let w = (Math.random() - 0.5) * 2;

        const axis = Math.floor(Math.random() * 4);
        const val = Math.random() > 0.5 ? 1 : -1;
        if(axis === 0) x = val;
        else if(axis === 1) y = val;
        else if(axis === 2) z = val;
        else w = val;

        positions4DStrg[i4] = x * TESSERACT_SCALE;
        positions4DStrg[i4+1] = y * TESSERACT_SCALE;
        positions4DStrg[i4+2] = z * TESSERACT_SCALE;
        positions4DStrg[i4+3] = w * TESSERACT_SCALE;

        positions3D[i3] = x * TESSERACT_SCALE; 
        positions3D[i3+1] = y * TESSERACT_SCALE; 
        positions3D[i3+2] = z * TESSERACT_SCALE;
        
        // Initialize to Pure White (RGB 1,1,1)
        colors[i3] = 1.0; 
        colors[i3+1] = 1.0; 
        colors[i3+2] = 1.0;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions3D, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.9, // Slightly larger particles for white glow
        map: createGlintTexture(),
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // --- WIREFRAME EDGES (Updated to White) ---
    const vertices4D = [];
    for(let i=0; i<16; i++) {
        const x = (i & 1) ? 1 : -1; const y = (i & 2) ? 1 : -1;
        const z = (i & 4) ? 1 : -1; const w = (i & 8) ? 1 : -1;
        vertices4D.push([x*TESSERACT_SCALE, y*TESSERACT_SCALE, z*TESSERACT_SCALE, w*TESSERACT_SCALE]);
    }

    const edgeIndices = [];
    for (let i = 0; i < 16; i++) {
        for (let j = i + 1; j < 16; j++) {
            let diff = 0;
            if(vertices4D[i][0] !== vertices4D[j][0]) diff++;
            if(vertices4D[i][1] !== vertices4D[j][1]) diff++;
            if(vertices4D[i][2] !== vertices4D[j][2]) diff++;
            if(vertices4D[i][3] !== vertices4D[j][3]) diff++;
            if (diff === 1) edgeIndices.push(i, j);
        }
    }

    const lineGeometry = new THREE.BufferGeometry();
    const linePositions = new Float32Array(edgeIndices.length * 3);
    lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
    // Change line color to white (0xffffff)
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending });
    const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
    scene.add(lines);

    // --- HAND TRACKING ---
    let handX = 0.5; let handY = 0.5;
    let isPinching = false; let handPresent = false;
    const videoElement = document.getElementById('input_video');
    const loadingElement = document.getElementById('loading');

    function onResults(results) {
        loadingElement.style.display = 'none';
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handPresent = true;
            const lm = results.multiHandLandmarks[0];
            handX = 1.0 - lm[8].x; handY = lm[8].y;
            const dist = Math.sqrt(Math.pow(lm[8].x - lm[4].x, 2) + Math.pow(lm[8].y - lm[4].y, 2));
            isPinching = dist < 0.05;
        } else { handPresent = false; isPinching = false; }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1 });
    hands.onResults(onResults);
    const cameraUtils = new Camera(videoElement, { onFrame: async () => await hands.send({image: videoElement}), width: 640, height: 480 });
    cameraUtils.start();

    // --- ANIMATION LOOP ---
    let currentRotXW = 0.5;
    let currentRotYW = 0.5;
    // Define the constant white color once
    const whiteColor = new THREE.Color(0xffffff);

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        const currentPositions = geometry.attributes.position.array;
        const currentColors = geometry.attributes.color.array;

        if(handPresent) {
            const targetXW = (handX - 0.5) * Math.PI * 2;
            const targetYW = (handY - 0.5) * Math.PI * 2;
            currentRotXW += (targetXW - currentRotXW) * 0.1;
            currentRotYW += (targetYW - currentRotYW) * 0.1;
        }

        let expansion = isPinching ? 2.0 : 1.0;

        // --- UPDATE PARTICLES ---
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i4 = i*4; const i3 = i*3;
            let p4 = [positions4DStrg[i4], positions4DStrg[i4+1], positions4DStrg[i4+2], positions4DStrg[i4+3]];
            
            rotateXW(p4, currentRotXW);
            rotateYW(p4, currentRotYW);

            const target3D = [0,0,0];
            project4Dto3D(p4[0], p4[1], p4[2], p4[3], target3D, 0);

            currentPositions[i3]   += (target3D[0] * expansion - currentPositions[i3]) * 0.1;
            currentPositions[i3+1] += (target3D[1] * expansion - currentPositions[i3+1]) * 0.1;
            currentPositions[i3+2] += (target3D[2] * expansion - currentPositions[i3+2]) * 0.1;

            // Ensure color stays pure white (lerp towards white)
            currentColors[i3]   += (whiteColor.r - currentColors[i3]) * 0.1;
            currentColors[i3+1] += (whiteColor.g - currentColors[i3+1]) * 0.1;
            currentColors[i3+2] += (whiteColor.b - currentColors[i3+2]) * 0.1;
        }
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;

        // --- UPDATE WIREFRAME ---
        const linePosAttr = lineGeometry.attributes.position.array;
        const projectedVertices = [];
        for(let i=0; i<16; i++) {
             let v4 = [...vertices4D[i]];
             rotateXW(v4, currentRotXW); rotateYW(v4, currentRotYW); 
             const v3 = [0,0,0];
             project4Dto3D(v4[0], v4[1], v4[2], v4[3], v3, 0);
             projectedVertices.push(v3);
        }
        for(let i=0; i<edgeIndices.length; i+=2) {
            const vStart = projectedVertices[edgeIndices[i]];
            const vEnd = projectedVertices[edgeIndices[i+1]];
            const li = i*3;
            linePosAttr[li] = vStart[0] * expansion; linePosAttr[li+1] = vStart[1] * expansion; linePosAttr[li+2] = vStart[2] * expansion;
            linePosAttr[li+3] = vEnd[0] * expansion; linePosAttr[li+4] = vEnd[1] * expansion; linePosAttr[li+5] = vEnd[2] * expansion;
        }
        lineGeometry.attributes.position.needsUpdate = true;
        // Ensure lines stay white
        lineMaterial.color.lerp(whiteColor, 0.1);

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    animate();
</script>
</body>
</html>